#!/usr/bin/env python3
import os
import time
import json
from decimal import Decimal, InvalidOperation

import psycopg
from psycopg.rows import dict_row

DB_URL = os.getenv("DB_URL")
if not DB_URL:
    raise SystemExit("DB_URL not set")

# Strategy label stored on orders table
EXEC_STRATEGY = os.getenv("MR_STRATEGY", "mean_reversion_v1")

POLL_SECS = float(os.getenv("MR_INTENT_POLL_SECS", "2.0"))
BATCH = int(os.getenv("MR_INTENT_BATCH", "25"))

# Safety: default to paper always in this worker
PAPER = True


def dec(x) -> Decimal:
    try:
        return Decimal(str(x))
    except (InvalidOperation, TypeError):
        return Decimal("0")


def main():
    print(
        f"[intent2orders] started strategy={EXEC_STRATEGY} "
        f"paper={PAPER} poll={POLL_SECS}s batch={BATCH}"
    )

    with psycopg.connect(DB_URL, row_factory=dict_row) as conn:
        conn.autocommit = True

        while True:
            with conn.cursor() as cur:
                # Lock a small batch so multiple workers won't duplicate.
                cur.execute(
                    """
                    WITH picked AS (
                      SELECT id, created_ts, market_id, outcome, entry_price, size_usd, dislocation
                      FROM mr_trade_intents
                      WHERE status = 'new'
                      ORDER BY id ASC
                      LIMIT %s
                      FOR UPDATE SKIP LOCKED
                    )
                    SELECT * FROM picked;
                    """,
                    (BATCH,),
                )
                intents = cur.fetchall()

                if not intents:
                    time.sleep(POLL_SECS)
                    continue

                for it in intents:
                    intent_id = it["id"]
                    market_id = it["market_id"]
                    outcome = it["outcome"]
                    limit_px = dec(it["entry_price"])
                    size_usd = dec(it["size_usd"])
                    dislo = it.get("dislocation")

                    if limit_px <= 0:
                        # mark bad intent so it doesn't loop forever
                        cur.execute(
                            "UPDATE mr_trade_intents "
                            "SET status='error', note='bad_entry_price' "
                            "WHERE id=%s",
                            (intent_id,),
                        )
                        print(f"[intent2orders] intent={intent_id} -> error bad_entry_price")
                        continue

                    # qty in shares/contracts: size_usd / price
                    qty = (size_usd / limit_px) if size_usd > 0 else Decimal("0")
                    if qty <= 0:
                        cur.execute(
                            "UPDATE mr_trade_intents "
                            "SET status='error', note='bad_size' "
                            "WHERE id=%s",
                            (intent_id,),
                        )
                        print(f"[intent2orders] intent={intent_id} -> error bad_size")
                        continue

                    # We store outcome + diagnostics in metadata.
                    metadata = {
                        "source": "mr_trade_intents",
                        "intent_id": int(intent_id),
                        "outcome": int(outcome),
                        "dislocation": str(dislo) if dislo is not None else None,
                        "entry_price": str(limit_px),
                        "size_usd": str(size_usd),
                    }

                    # Insert paper order (no live execution yet)
                    cur.execute(
                        """
                        INSERT INTO strategy_orders (
                          strategy, market_id, side, qty, limit_px, status, paper,
                          intent_id, outcome, metadata
                        )
                        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s::jsonb)
                        ON CONFLICT (intent_id) DO NOTHING
                        RETURNING id;
                        """,
                        (
                            EXEC_STRATEGY,
                            market_id,
                            "buy",
                            qty,
                            limit_px,
                            "submitted",
                            PAPER,
                            int(intent_id),
                            int(outcome),
                            json.dumps(metadata),
                        ),
                    )

                    row = cur.fetchone()

                    if row is None:
                        # Conflict happened (order already exists for this intent_id).
                        # Fetch existing order id so we can link the intent and move on.
                        cur.execute(
                            "SELECT id FROM strategy_orders WHERE intent_id=%s",
                            (int(intent_id),),
                        )
                        row2 = cur.fetchone()
                        if row2 is None:
                            # Shouldn't happen if DB is consistent, but don't loop forever.
                            cur.execute(
                                "UPDATE mr_trade_intents "
                                "SET status='error', note='order_missing_after_conflict' "
                                "WHERE id=%s",
                                (intent_id,),
                            )
                            print(
                                f"[intent2orders] intent={intent_id} -> error order_missing_after_conflict"
                            )
                            continue
                        order_id = row2["id"]
                    else:
                        order_id = row["id"]

                    # Mark intent as queued (so it is not duplicated)
                    cur.execute(
                        "UPDATE mr_trade_intents SET status='queued', order_id=%s WHERE id=%s",
                        (order_id, intent_id),
                    )

                    print(
                        f"[intent2orders] intent={intent_id} -> strategy_orders.id={order_id} "
                        f"market={market_id} outcome={outcome} px={limit_px} qty={qty}"
                    )

            # short sleep between loops even if we processed a batch
            time.sleep(0.05)


if __name__ == "__main__":
    main()